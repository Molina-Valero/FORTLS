circ = as.numeric(), arc.cir = as.numeric())
for (i in unique(filteraux$tree)) {
.filt <- filteraux[filteraux$tree == i, ]
.filt <- .filt[.filt$dist < mean(.filt$dist, na.rm = TRUE) + mean(.filt$radius, na.rm = TRUE), ]
if(nrow(.filt) < 1){next}
if(nrow(.filt) == 1){
.filt$dif <- NA
.filter <- rbind(.filter, .filt)
next
}
.filt$dif <- c(diff(.filt$radius), diff(.filt$radius)[length(diff(.filt$radius))])
.filt$dif.sec <- c(abs(diff(.filt$sec)), abs(diff(.filt$sec))[length(abs(diff(.filt$sec)))])
.filt$dif <- ifelse(.filt$dif.sec > 1, .filt$dif * .filt$dif.sec, .filt$dif)
threshold <- mean(.filt$radius) / 2
.filt <- .filt[.filt$dif < threshold & .filt$dif > - threshold, ]
if(nrow(.filt) < 1){next}
if(nrow(.filt) == 1){
.filt <- .filt[, -ncol(.filt)]
.filter <- rbind(.filter, .filt)
next
}
while (max(.filt$dif) >= threshold / 2 & min(.filt$dif) <= -threshold) {
.filt <- .filt[.filt$dif < threshold / 2 & .filt$dif > -threshold, ]
.filt$dif <- c(diff(.filt$radius), diff(.filt$radius)[length(diff(.filt$radius))])
.filt$dif.sec <- c(abs(diff(.filt$sec)), abs(diff(.filt$sec))[length(abs(diff(.filt$sec)))])
.filt$dif <- ifelse(.filt$dif.sec > 1, .filt$dif * .filt$dif.sec, .filt$dif)
}
.filt <- .filt[, -ncol(.filt)]
.filter <- rbind(.filter, .filt)
}
return(.filter)
}
# Function to fit a circle through three points
.fit_circle <- function(points) {
x <- points[, 1]
y <- points[, 2]
D <- 2 * (x[1] * (y[2] - y[3]) + x[2] * (y[3] - y[1]) + x[3] * (y[1] - y[2]))
Ux <- ((x[1]^2 + y[1]^2) * (y[2] - y[3]) + (x[2]^2 + y[2]^2) * (y[3] - y[1]) + (x[3]^2 + y[3]^2) * (y[1] - y[2])) / D
Uy <- ((x[1]^2 + y[1]^2) * (x[3] - x[2]) + (x[2]^2 + y[2]^2) * (x[1] - x[3]) + (x[3]^2 + y[3]^2) * (x[2] - x[1])) / D
center <- c(Ux, Uy)
radius <- sqrt((x[1] - Ux)^2 + (y[1] - Uy)^2)
return(list(center = center, radius = radius))
}
.RANSAC <- function(data){
dat <- data
dist <- 0.05
inliers <- dat[sample(nrow(dat), 3), ]
fit <- .fit_circle(inliers)
radio <- sqrt((dat[, "x"] - fit$center[1]) ^ 2 + (dat[, "y"] - fit$center[2]) ^ 2)
dat <- cbind(dat, radio)
inliers <- abs(fit$radius-dat[, "radio"])
dat <- cbind(dat, inliers)
dat <- dat[dat[, "inliers"] < dist, ]
if(length(dat) == 0 | nrow(dat) < 2){
out <- data.frame(x = as.numeric(), y = as.numeric(),
radio = as.numeric(), n = as.numeric(), mae = as.numeric(), cv = as.numeric())
return(out)}
dat <- dat[, c("x", "y")]
inliers <- dat[sample(nrow(dat), 3), ]
fit <- .fit_circle(inliers)
radio <- sqrt((dat[, "x"] - fit$center[1]) ^ 2 + (dat[, "y"] - fit$center[2]) ^ 2)
dat <- cbind(dat, radio)
inliers <- abs(fit$radius-dat[, "radio"])
dat <- cbind(dat, inliers)
dat <- dat[dat[, "inliers"] < dist, ]
if(length(dat) == 0 | nrow(dat) < 2){
out <- data.frame(x = as.numeric(), y = as.numeric(),
radio = as.numeric(), n = as.numeric(), mae = as.numeric(), cv = as.numeric())
return(out)}
mae <- abs(sum(coef(fit)[1]-dat[, 3])) / nrow(dat)
cv <- stats::sd(raster::pointDistance(dat[, c("x", "y")], c(fit$center[1], fit$center[2]), lonlat = FALSE)) / fit$radius
out <- data.frame(x = fit$center[1], y = fit$center[2], radio = fit$radius, n = nrow(dat), mae = mae, cv = cv)
return(out)
}
single.tree = NULL
dbh.min = 4
dbh.max = 200
h.min = 1.3
ncr.threshold = 0.1
tls.precision = NULL
density.reduction = 2
stem.section = c(0.7, 3.5)
stem.range = NULL
bark.roughness = 1
slice = 0.1
understory = NULL
den.type = 1
d.top = NULL
plot.attributes = NULL
plot = TRUE
save.result = TRUE
data <- SingleScan
set.seed(123)
data <- data.table::setDT(data)
#### Checking some function arguments ####
# Obtaining working directory for saving files
if(is.null(dir.result))
dir.result <- getwd()
.dbh.min <- dbh.min / 100
.dbh.max <- dbh.max / 100
breaks = c(1, 1.3, 1.6)
tls.resolution = list(point.dist = 7.67, tls.dist = 10)
if(is.null(tls.resolution))
stop("The argument tls.resolution must be defined")
.point.dist <- tls.resolution$point.dist / 1000
.tls.dist <- tls.resolution$tls.dist
# If resolution is defined by angles (?):
.vertical.angle <- tls.resolution$vertical.angle * 2 * pi / 360
.horizontal.angle <- tls.resolution$horizontal.angle * 2 * pi / 360
# Define angle aperture according to available TLS resolution parameters:
# Angular resolution:
if(is.null(.point.dist)){
.alpha.v <- .vertical.angle
.alpha.h <- .horizontal.angle
} else {
.alpha.v <- atan((.point.dist / 2) / .tls.dist) * 2
.alpha.h <- .alpha.v
}
# Obtaining Cartesian coordinates (x,y) from center
kk <- data[data$phi < (pi/2) & data$prob.selec == 1, c("x", "y", "phi", "rho")]
x.center <- mean(kk$x - sin(kk$phi) * kk$rho)
y.center <- mean(kk$y - cos(kk$phi) * kk$rho)
rm(kk)
#### Detecting possible areas with trees in the point cloud ####
if(!is.null(data$GLA)){
woody <- data[data$GLA <= 0, ]
woody <- woody[!is.na(woody$x) & !is.na(woody$y) & !is.na(woody$z), ]} else {woody <- data}
if(!is.null(data$intensity) & suppressWarnings(mean(data$intensity, na.rm = T)) > 0 & is.null(data$GLA)){
woody <- data[data$intensity > mean(data$intensity, na.rm = T), ]
}
if(!is.null(data$intensity) & suppressWarnings(mean(data$intensity, na.rm = T)) > 0 & !is.null(data$GLA)){
woody <- woody[woody$intensity > mean(woody$intensity, na.rm = T), ]
}
#
message("Statistical filtering of the whole point cloud")
woody <- woody[, c("x", "y", "z")]
woody <- VoxR::filter_noise(data = data.table::setDT(woody), store_noise = TRUE, message = FALSE)
# noise <- woody[woody$Noise == 2, ]
woody <- woody[woody$Noise == 1, ]
woody <- merge(data, woody[, c("x", "y", "z")], by = c("x", "y", "z"), all = FALSE)
stem <- woody
if(is.null(stem.section)){
stem.section <- .getStem(stem)
stem.section <- c(stem.section$x, stem.section$x + stem.section$diff)
stem <- stem[stem$z > stem.section[1] & stem$z < stem.section[2], ]
} else {
stem <- stem[stem$z > stem.section[1] & stem$z < stem.section[2], ]
}
message("Retaining points with high verticality values")
message("Detecting tree stem axes")
stem <- stem[stem$prob.selec == 1, ]
if(is.null(tls.precision)){
stem <- VoxR::vox(stem[, c("x", "y", "z")], res = 0.03)} else {
stem <- VoxR::vox(stem[, c("x", "y", "z")], res = tls.precision)}
stem <- stem[, c("x", "y", "z", "npts")]
stem <- VoxR::project_voxels(stem)
stem.2 <- NULL
if(density.reduction == 1)
stem <- stem[stem$npts > mean(stem$npts) & stem$nvox > mean(stem$nvox), ]
if(density.reduction == 2)
stem <- stem[stem$npts > mean(stem$npts) & stem$nvox > mean(stem$nvox) & stem$ratio > mean(stem$ratio), ]
if(!is.null(understory)){
if(is.null(single.tree))
stem.2 <- stem[stem$npts > mean(stem$npts), ]
stem <- stem[stem$npts > mean(stem$npts) & stem$ratio > mean(stem$ratio) & stem$nvox > mean(stem$nvox), ]
}
buf <- sf::st_as_sf(data.frame(stem), coords = c("x","y"))
buf <- sf::st_buffer(buf, max(.dbh.min, 0.5))
buf <- sf::st_cast(sf::st_union(buf), "POLYGON")
rm(stem)
if(!is.null(understory) & is.null(single.tree)){
buf.2 <- sf::st_as_sf(stem.2, coords = c("x","y"))
# sf::st_crs(buf) <- "+proj=utm +zone=19 +ellps=GRS80 +datum=NAD83 +unit=m"
buf.2 <- sf::st_buffer(buf.2, max(.dbh.min, 0.5))
buf.2 <- sf::st_difference(sf::st_union(buf.2), buf, 0.1)
# Detection of stem part without shrub vegetation and crown
buf.2 <- buf.2[sf::st_area(buf.2) > (pi / 4)*(.dbh.min + 0.1) ^ 2]
if(length(buf.2) < 1){
stem.2 <- NULL
} else {
stem.2 <- woody[woody$prob.selec == 1, ]
stem.3 <- sf::st_intersects(buf, sf::st_as_sf(stem.2, coords = c("x","y")))
stem.3 <- data.table::setDT(as.data.frame(stem.3))
colnames(stem.3) <- c("tree", "code")
stem.2$code <- as.numeric(row.names(stem.2))
stem.2 <- merge(stem.2, stem.3, by = "code", all = FALSE)
# stem.2 <- subset(stem.2, select = -code)
stem.2 <- stem.2[, 2:ncol(stem.2)]
rm(stem.3)
if(nrow(stem.2) < 1)
stem.2 <- NULL
}
rm(buf.2)
}
woody.2 <- sf::st_intersects(buf, sf::st_as_sf(data.frame(woody), coords = c("x","y")))
woody.2 <- data.table::setDT(as.data.frame(woody.2))
colnames(woody.2) <- c("tree", "code")
woody$code <- as.numeric(row.names(woody))
woody <- merge(woody, woody.2, by = "code", all = FALSE)
# woody <- subset(woody, select = -code)
woody <- woody[, !(names(woody) %in% c("code"))]
woody <- woody[!is.na(woody$tree), ]
SingleScan <- normalize(las = "Congestion004.laz", id = "Congestion004",
x.center = 0, y.center = 0,
max.dist = 15,
dir.data = dir.data, dir.result = dir.result)
data = SingleScan
set.seed(123)
data <- data.table::setDT(data)
#### Checking some function arguments ####
# Obtaining working directory for saving files
if(is.null(dir.result))
dir.result <- getwd()
# Converting arguments to International System of Units
# Arguments of the forest inventory
.dbh.min <- dbh.min / 100
.dbh.max <- dbh.max / 100
# Arguments of the TLS precision
# If resolution is defined by points distance at a certain distance from TLS (mm/m):
if(is.null(tls.resolution))
stop("The argument tls.resolution must be defined")
.point.dist <- tls.resolution$point.dist / 1000
.tls.dist <- tls.resolution$tls.dist
# If resolution is defined by angles (?):
.vertical.angle <- tls.resolution$vertical.angle * 2 * pi / 360
.horizontal.angle <- tls.resolution$horizontal.angle * 2 * pi / 360
# Define angle aperture according to available TLS resolution parameters:
# Angular resolution:
if(is.null(.point.dist)){
.alpha.v <- .vertical.angle
.alpha.h <- .horizontal.angle
} else {
.alpha.v <- atan((.point.dist / 2) / .tls.dist) * 2
.alpha.h <- .alpha.v
}
# Obtaining Cartesian coordinates (x,y) from center
kk <- data[data$phi < (pi/2) & data$prob.selec == 1, c("x", "y", "phi", "rho")]
x.center <- mean(kk$x - sin(kk$phi) * kk$rho)
y.center <- mean(kk$y - cos(kk$phi) * kk$rho)
rm(kk)
#### Detecting possible areas with trees in the point cloud ####
if(!is.null(data$GLA)){
woody <- data[data$GLA <= 0, ]
woody <- woody[!is.na(woody$x) & !is.na(woody$y) & !is.na(woody$z), ]} else {woody <- data}
if(!is.null(data$intensity) & suppressWarnings(mean(data$intensity, na.rm = T)) > 0 & is.null(data$GLA)){
woody <- data[data$intensity > mean(data$intensity, na.rm = T), ]
}
if(!is.null(data$intensity) & suppressWarnings(mean(data$intensity, na.rm = T)) > 0 & !is.null(data$GLA)){
woody <- woody[woody$intensity > mean(woody$intensity, na.rm = T), ]
}
# Statistical filtering of a point cloud
# Implements the Statistical Outliers Removal (SOR)
message("Statistical filtering of the whole point cloud")
woody <- woody[, c("x", "y", "z")]
woody <- VoxR::filter_noise(data = data.table::setDT(woody), store_noise = TRUE, message = FALSE)
# noise <- woody[woody$Noise == 2, ]
woody <- woody[woody$Noise == 1, ]
woody <- merge(data, woody[, c("x", "y", "z")], by = c("x", "y", "z"), all = FALSE)
# noise <- merge(data, noise, by = c("x", "y", "z"), all = FALSE)
# Detection of stem part without shrub vegetation and crown
stem <- woody
# Defining the vertical section in which trees are detected
if(is.null(stem.section)){
stem.section <- .getStem(stem)
stem.section <- c(stem.section$x, stem.section$x + stem.section$diff)
stem <- stem[stem$z > stem.section[1] & stem$z < stem.section[2], ]
} else {
stem <- stem[stem$z > stem.section[1] & stem$z < stem.section[2], ]
}
message("Retaining points with high verticality values")
# stem <- .ver.remove.slice.double(stem)
# stem$ver <- ifelse(is.na(stem$ver), stats::runif(length(stem$ver[is.na(stem$ver)])), stem$ver)
# stem$ver <- 1 - stem$ver
# stem$prob.ver <- stats::runif(nrow(stem))
# stem <- stem[stem$ver > stem$prob.ver, ]
#
# woody <- woody[woody$z <= stem.section[1] | woody$z >= stem.section[2], ]
# woody <- rbind(woody, stem[, 1:ncol(woody)])
message("Detecting tree stem axes")
stem <- stem[stem$prob.selec == 1, ]
if(is.null(tls.precision)){
stem <- VoxR::vox(stem[, c("x", "y", "z")], res = 0.03)} else {
stem <- VoxR::vox(stem[, c("x", "y", "z")], res = tls.precision)}
stem <- stem[, c("x", "y", "z", "npts")]
stem <- VoxR::project_voxels(stem)
# plot(stem$x, stem$y, asp = 1, col = "grey")
# Filtering pixels - double branch peeling
stem.2 <- NULL
if(density.reduction == 1)
stem <- stem[stem$npts > mean(stem$npts) & stem$nvox > mean(stem$nvox), ]
if(density.reduction == 2)
stem <- stem[stem$npts > mean(stem$npts) & stem$nvox > mean(stem$nvox) & stem$ratio > mean(stem$ratio), ]
if(!is.null(understory)){
if(is.null(single.tree))
stem.2 <- stem[stem$npts > mean(stem$npts), ]
stem <- stem[stem$npts > mean(stem$npts) & stem$ratio > mean(stem$ratio) & stem$nvox > mean(stem$nvox), ]
}
buf <- sf::st_as_sf(data.frame(stem), coords = c("x","y"))
buf <- sf::st_buffer(buf, max(.dbh.min, 0.5))
buf <- sf::st_cast(sf::st_union(buf), "POLYGON")
rm(stem)
if(!is.null(understory) & is.null(single.tree)){
buf.2 <- sf::st_as_sf(stem.2, coords = c("x","y"))
# sf::st_crs(buf) <- "+proj=utm +zone=19 +ellps=GRS80 +datum=NAD83 +unit=m"
buf.2 <- sf::st_buffer(buf.2, max(.dbh.min, 0.5))
buf.2 <- sf::st_difference(sf::st_union(buf.2), buf, 0.1)
# Detection of stem part without shrub vegetation and crown
buf.2 <- buf.2[sf::st_area(buf.2) > (pi / 4)*(.dbh.min + 0.1) ^ 2]
if(length(buf.2) < 1){
stem.2 <- NULL
} else {
stem.2 <- woody[woody$prob.selec == 1, ]
stem.3 <- sf::st_intersects(buf, sf::st_as_sf(stem.2, coords = c("x","y")))
stem.3 <- data.table::setDT(as.data.frame(stem.3))
colnames(stem.3) <- c("tree", "code")
stem.2$code <- as.numeric(row.names(stem.2))
stem.2 <- merge(stem.2, stem.3, by = "code", all = FALSE)
# stem.2 <- subset(stem.2, select = -code)
stem.2 <- stem.2[, 2:ncol(stem.2)]
rm(stem.3)
if(nrow(stem.2) < 1)
stem.2 <- NULL
}
rm(buf.2)
}
woody.2 <- sf::st_intersects(buf, sf::st_as_sf(data.frame(woody), coords = c("x","y")))
woody.2 <- data.table::setDT(as.data.frame(woody.2))
colnames(woody.2) <- c("tree", "code")
woody$code <- as.numeric(row.names(woody))
woody <- merge(woody, woody.2, by = "code", all = FALSE)
# woody <- subset(woody, select = -code)
woody <- woody[, !(names(woody) %in% c("code"))]
woody
View(woody.2)
set.seed(123)
data <- data.table::setDT(data)
#### Checking some function arguments ####
# Obtaining working directory for saving files
if(is.null(dir.result))
dir.result <- getwd()
# Converting arguments to International System of Units
# Arguments of the forest inventory
.dbh.min <- dbh.min / 100
.dbh.max <- dbh.max / 100
# Arguments of the TLS precision
# If resolution is defined by points distance at a certain distance from TLS (mm/m):
if(is.null(tls.resolution))
stop("The argument tls.resolution must be defined")
.point.dist <- tls.resolution$point.dist / 1000
.tls.dist <- tls.resolution$tls.dist
# If resolution is defined by angles (?):
.vertical.angle <- tls.resolution$vertical.angle * 2 * pi / 360
.horizontal.angle <- tls.resolution$horizontal.angle * 2 * pi / 360
# Define angle aperture according to available TLS resolution parameters:
# Angular resolution:
if(is.null(.point.dist)){
.alpha.v <- .vertical.angle
.alpha.h <- .horizontal.angle
} else {
.alpha.v <- atan((.point.dist / 2) / .tls.dist) * 2
.alpha.h <- .alpha.v
}
# Obtaining Cartesian coordinates (x,y) from center
kk <- data[data$phi < (pi/2) & data$prob.selec == 1, c("x", "y", "phi", "rho")]
x.center <- mean(kk$x - sin(kk$phi) * kk$rho)
y.center <- mean(kk$y - cos(kk$phi) * kk$rho)
rm(kk)
#### Detecting possible areas with trees in the point cloud ####
if(!is.null(data$GLA)){
woody <- data[data$GLA <= 0, ]
woody <- woody[!is.na(woody$x) & !is.na(woody$y) & !is.na(woody$z), ]} else {woody <- data}
if(!is.null(data$intensity) & suppressWarnings(mean(data$intensity, na.rm = T)) > 0 & is.null(data$GLA)){
woody <- data[data$intensity > mean(data$intensity, na.rm = T), ]
}
if(!is.null(data$intensity) & suppressWarnings(mean(data$intensity, na.rm = T)) > 0 & !is.null(data$GLA)){
woody <- woody[woody$intensity > mean(woody$intensity, na.rm = T), ]
}
woody <- woody[, c("x", "y", "z")]
woody <- VoxR::filter_noise(data = data.table::setDT(woody), store_noise = TRUE, message = FALSE)
# noise <- woody[woody$Noise == 2, ]
woody <- woody[woody$Noise == 1, ]
woody <- merge(data, woody[, c("x", "y", "z")], by = c("x", "y", "z"), all = FALSE)
stem <- woody
stem.section
if(is.null(stem.section)){
stem.section <- .getStem(stem)
stem.section <- c(stem.section$x, stem.section$x + stem.section$diff)
stem <- stem[stem$z > stem.section[1] & stem$z < stem.section[2], ]
} else {
stem <- stem[stem$z > stem.section[1] & stem$z < stem.section[2], ]
}
stem <- stem[stem$prob.selec == 1, ]
if(is.null(tls.precision)){
stem <- VoxR::vox(stem[, c("x", "y", "z")], res = 0.03)} else {
stem <- VoxR::vox(stem[, c("x", "y", "z")], res = tls.precision)}
stem <- stem[, c("x", "y", "z", "npts")]
stem <- VoxR::project_voxels(stem)
stem.2 <- NULL
stem <- stem[stem$npts > mean(stem$npts) & stem$nvox > mean(stem$nvox) & stem$ratio > mean(stem$ratio), ]
understory
buf <- sf::st_as_sf(data.frame(stem), coords = c("x","y"))
buf <- sf::st_buffer(buf, max(.dbh.min, 0.5))
buf <- sf::st_cast(sf::st_union(buf), "POLYGON")
rm(stem)
single.tree
woody.2 <- sf::st_intersects(buf, sf::st_as_sf(data.frame(woody), coords = c("x","y")))
woody.2 <- data.table::setDT(as.data.frame(woody.2))
colnames(woody.2) <- c("tree", "code")
woody$code <- as.numeric(row.names(woody))
woody <- merge(woody, woody.2, by = "code", all = FALSE)
# woody <- subset(woody, select = -code)
woody <- woody[, !(names(woody) %in% c("code"))]
View(woody.2)
remove.packages("FORTLS")
library(lidR)
setwd("C:/pruebas")
kk <- readLAS("Congestion004.laz")
writeLAS(kk, "C:/pruebas/kk.laz")
id <- 1
i <- 1
paste(dir.result, "/tree", id, i, ".laz", sep = "")
dir.data <- "C:/pruebas"
dir.result <- "C:/pruebas"
paste(dir.result, "/tree", id, i, ".laz", sep = "")
library(FORTLS)
dir.data <- "C:/pruebas"
dir.result <- "C:/pruebas"
SingleScan <- normalize(las = "Congestion004.laz", id = "Congestion004",
x.center = 0, y.center = 0,
max.dist = 5,
dir.data = dir.data, dir.result = dir.result)
treeSingleScan <- tree.detection.single.scan(
data = SingleScan,
breaks = c(1, 1.3, 1.6),
tls.resolution = list(point.dist = 7.67, tls.dist = 10),
segmentation = TRUE,
dir.result = dir.result)
x <- 0
y <- 0
dist <- 1
id <- 1
i <- 1
lidR::writeLAS(lidR::clip_circle(kk, x, y, dist),
paste(dir.result, "/tree", id, i, ".laz", sep = ""))
library(FORTLS)
dir.data <- "C:/pruebas"
dir.result <- "C:/pruebas"
SingleScan <- normalize(las = "Congestion004.laz", id = "Congestion004",
x.center = 0, y.center = 0,
max.dist = 5,
dir.data = dir.data, dir.result = dir.result)
treeSingleScan <- tree.detection.single.scan(
data = SingleScan,
breaks = 1.3,
tls.resolution = list(point.dist = 7.67, tls.dist = 10),
segmentation = TRUE,
dir.result = dir.result)
library(FORTLS)
dir.data <- "C:/pruebas"
dir.result <- "C:/pruebas"
SingleScan <- normalize(las = "Congestion004.laz", id = "Congestion004",
x.center = 0, y.center = 0,
max.dist = 5,
dir.data = dir.data, dir.result = dir.result)
treeSingleScan <- tree.detection.single.scan(
data = SingleScan,
breaks = 1.3,
tls.resolution = list(point.dist = 7.67, tls.dist = 10),
segmentation = TRUE,
dir.result = dir.result)
View(treeSingleScan)
diff(treeSingleScan$h.dist)
mean(diff(treeSingleScan$h.dist))
library(FORTLS)
dir.data <- "C:/pruebas"
dir.result <- "C:/pruebas"
SingleScan <- normalize(las = "Congestion004.laz", id = "Congestion004",
x.center = 0, y.center = 0,
max.dist = 5,
dir.data = dir.data, dir.result = dir.result)
treeSingleScan <- tree.detection.single.scan(
data = SingleScan,
breaks = 1.3,
tls.resolution = list(point.dist = 7.67, tls.dist = 10),
segmentation = TRUE,
dir.result = dir.result)
treeLAS <- lidR::LAS(kk[, c("x","y","z")])
kk <- readLAS("Congestion004.laz")
setwd("C:/pruebas")
kk <- readLAS("Congestion004.laz")
treeLAS <- lidR::LAS(kk[, c("x","y","z")])
setwd("C:/pruebas")
kk <- readLAS("Congestion004.laz")
library(lidR)
kk <- readLAS("Congestion004.laz")
treeLAS <- lidR::LAS(kk[, c("x","y","z")])
id <- 1
i <- 1
x <- 0
y <- 0
dist <- 1
dir.data <- "C:/pruebas"
dir.result <- "C:/pruebas"
suppressWarnings(lidR::writeLAS(lidR::clip_circle(treeLAS, x, y, dist),
paste(dir.result, "/tree", id, i, ".laz", sep = "")))
treeLAS <- lidR::LAS(kk[, c("x","y","z")])
kk <- SingleScan
treeLAS <- lidR::LAS(kk[, c("x","y","z")])
treeLAS <- suppressWarnings(lidR::LAS(kk[, c("x","y","z")]))
treeLAS <- suppressMessages(lidR::LAS(kk[, c("x","y","z")]))
lidR::writeLAS(lidR::clip_circle(treeLAS, x, y, dist),
paste(dir.result, "/tree", id, i, ".laz", sep = ""))
